# üîÑ Sistema de An√°lise de Algoritmos de Ordena√ß√£o

[![C](https://img.shields.io/badge/Language-C-blue.svg)](https://en.wikipedia.org/wiki/C_(programming_language))
[![Version](https://img.shields.io/badge/Version-2.1-green.svg)]()
[![License](https://img.shields.io/badge/License-MIT-blue.svg)](LICENSE)
[![Platform](https://img.shields.io/badge/Platform-Windows%20%7C%20Linux%20%7C%20macOS-lightgrey.svg)]()
[![Precision](https://img.shields.io/badge/Timing-Nanosecond%20Precision-red.svg)]()

## üìã √çndice

1. [Sobre o Projeto](#-sobre-o-projeto)
2. [üÜï Novidades Vers√£o 2.1](#-novidades-vers√£o-21)
3. [Caracter√≠sticas Principais](#-caracter√≠sticas-principais)
4. [Algoritmos Implementados](#-algoritmos-implementados)
5. [Estrutura do Projeto](#-estrutura-do-projeto)
6. [Compila√ß√£o e Execu√ß√£o](#-compila√ß√£o-e-execu√ß√£o)
7. [Manual de Uso](#-manual-de-uso)
8. [An√°lise de Dados](#-an√°lise-de-dados)
9. [Arquivos de Sa√≠da](#-arquivos-de-sa√≠da)
10. [Documenta√ß√£o T√©cnica](#-documenta√ß√£o-t√©cnica)
11. [M√©tricas Analisadas](#-m√©tricas-analisadas)
12. [Contribui√ß√£o](#-contribui√ß√£o)
13. [Licen√ßa](#-licen√ßa)

## üéØ Sobre o Projeto

Este sistema implementa uma **an√°lise comparativa completa** de 7 algoritmos cl√°ssicos de ordena√ß√£o, desenvolvido em linguagem C com foco em **performance, precis√£o e usabilidade**. O projeto oferece uma interface interativa que permite testar algoritmos individualmente ou executar an√°lises automatizadas completas.

### üéì Objetivos Acad√™micos

- **Comparar empiricamente** diferentes algoritmos de ordena√ß√£o
- **Medir precisamente** tempo de execu√ß√£o, compara√ß√µes e trocas
- **Analisar estabilidade** dos algoritmos com dados reais
- **Gerar relat√≥rios detalhados** para an√°lise acad√™mica
- **Demonstrar implementa√ß√µes gen√©ricas** que funcionam com qualquer tipo de dados

## üÜï **Novidades Vers√£o 2.1**

### ‚ö° **Sistema de Medi√ß√£o de Alta Precis√£o**

A vers√£o 2.1 introduz um revolucion√°rio sistema de medi√ß√£o de tempo que **elimina completamente** o problema de algoritmos r√°pidos aparecerem com tempo zero nos relat√≥rios.

#### **üî¨ Tecnologias de Precis√£o Implementadas:**

| Plataforma | Fun√ß√£o Utilizada | Precis√£o | Caracter√≠sticas |
|------------|------------------|----------|------------------|
| **Windows** | `QueryPerformanceCounter` | **Microssegundos** | Hardware timer de alta resolu√ß√£o |
| **Linux/Unix** | `clock_gettime(CLOCK_MONOTONIC)` | **Nanossegundos** | Timer monot√¥nico do kernel |
| **Fallback** | `gettimeofday()` | **Microssegundos** | Compatibilidade universal |

#### **üìä Medi√ß√£o Adaptativa Inteligente:**

O sistema agora ajusta automaticamente o n√∫mero de execu√ß√µes baseado no tamanho do conjunto:

- **< 100 elementos**: 10 execu√ß√µes ‚Üí m√©dia estat√≠stica
- **< 1.000 elementos**: 5 execu√ß√µes ‚Üí precis√£o balanceada  
- **< 10.000 elementos**: 3 execu√ß√µes ‚Üí otimiza√ß√£o de tempo
- **‚â• 10.000 elementos**: 1 execu√ß√£o ‚Üí medi√ß√£o √∫nica suficiente

### üîÑ **Sistema Dual: Otimizada + Did√°tica**

Implementa√ß√£o √∫nica que oferece **duas vers√µes** de cada algoritmo:

- **‚úÖ Vers√£o OTIMIZADA**: M√°xima performance com otimiza√ß√µes avan√ßadas
- **üìö Vers√£o N√ÉO OTIMIZADA**: Implementa√ß√£o did√°tica para fins educacionais

## ‚ú® Caracter√≠sticas Principais

### üéØ **Interface e Usabilidade**
- ‚úÖ Menu interativo limpo e intuitivo
- ‚úÖ Execu√ß√£o automatizada de todos os testes
- ‚úÖ Feedback visual em tempo real
- ‚úÖ Limpeza autom√°tica da tela entre opera√ß√µes

### üîß **Robustez T√©cnica**
- ‚úÖ **Algoritmos gen√©ricos** compat√≠veis com qualquer tipo de dados
- ‚úÖ **Detec√ß√£o autom√°tica** de caminhos de arquivos
- ‚úÖ **Sistema de fallback** para diferentes estruturas de projeto
- ‚úÖ **Tratamento robusto** de erros e casos extremos

### üìä **An√°lise Avan√ßada**
- ‚úÖ **Medi√ß√£o de alta precis√£o** at√© nanossegundos
- ‚úÖ **Contagem precisa** de compara√ß√µes e trocas
- ‚úÖ **An√°lise de estabilidade** com dados reais
- ‚úÖ **Rankings autom√°ticos** por diferentes m√©tricas

### üíæ **Organiza√ß√£o de Dados**
- ‚úÖ **Salvamento autom√°tico** em estrutura organizada
- ‚úÖ **Compatibilidade multiplataforma** (Windows/Linux/macOS)
- ‚úÖ **M√∫ltiplos formatos** de relat√≥rios
- ‚úÖ **Backup autom√°tico** em diferentes locais

## üßÆ Algoritmos Implementados

| Algoritmo | Complexidade (Melhor) | Complexidade (M√©dio) | Complexidade (Pior) | Est√°vel | Caracter√≠sticas |
|-----------|----------------------|---------------------|-------------------|---------|-----------------|
| **Insertion Sort** | O(n) | O(n¬≤) | O(n¬≤) | ‚úÖ Sim | Eficiente para pequenos conjuntos |
| **Bubble Sort** | O(n) | O(n¬≤) | O(n¬≤) | ‚úÖ Sim | Algor√≠tmo simples, did√°tico |
| **Selection Sort** | O(n¬≤) | O(n¬≤) | O(n¬≤) | ‚ùå N√£o | N√∫mero fixo de trocas |
| **Shaker Sort** | O(n) | O(n¬≤) | O(n¬≤) | ‚úÖ Sim | Bubble sort bidirecional |
| **Shell Sort** | O(n log n) | O(n^1.25) | O(n¬≤) | ‚ùå N√£o | Insertion sort com incrementos |
| **Quick Sort** | O(n log n) | O(n log n) | O(n¬≤) | ‚ùå N√£o | Dividir para conquistar |
| **Heap Sort** | O(n log n) | O(n log n) | O(n log n) | ‚ùå N√£o | Garantia de O(n log n) |

### üèÜ **Caracter√≠sticas de Estabilidade**

```
üìù ALGORITMOS EST√ÅVEIS:
   ‚úÖ Insertion Sort  - Preserva ordem de elementos iguais
   ‚úÖ Bubble Sort     - Compara√ß√µes adjacentes mant√™m ordem
   ‚úÖ Shaker Sort     - Bubble Sort bidirecional est√°vel

‚ö†Ô∏è  ALGORITMOS N√ÉO EST√ÅVEIS:
   ‚ùå Selection Sort  - Troca elementos distantes
   ‚ùå Shell Sort      - Compara√ß√µes com gap podem quebrar estabilidade
   ‚ùå Quick Sort      - Particionamento pode reorganizar elementos iguais
   ‚ùå Heap Sort       - Constru√ß√£o do heap quebra ordem original
```

## üìÅ Estrutura do Projeto

```
trabalho-po-1/
‚îú‚îÄ‚îÄ üìÅ data/                          # Conjuntos de dados de teste
‚îÇ   ‚îú‚îÄ‚îÄ üìÑ alunos.txt                 # Dados estruturados (nome, data, bairro, cidade)
‚îÇ   ‚îú‚îÄ‚îÄ üìÑ numeros_pequeno.txt        # ~100 elementos
‚îÇ   ‚îú‚îÄ‚îÄ üìÑ numeros_medio.txt          # ~1.000 elementos  
‚îÇ   ‚îú‚îÄ‚îÄ üìÑ numeros_grande.txt         # ~10.000 elementos
‚îÇ   ‚îú‚îÄ‚îÄ üìÑ numeros_ordenados.txt      # Melhor caso (j√° ordenados)
‚îÇ   ‚îú‚îÄ‚îÄ üìÑ numeros_reversos.txt       # Pior caso (ordem inversa)
‚îÇ   ‚îî‚îÄ‚îÄ üìÑ numeros_duplicados.txt     # Elementos repetidos
‚îÇ
‚îú‚îÄ‚îÄ üìÅ include/                       # Headers e defini√ß√µes
‚îÇ   ‚îî‚îÄ‚îÄ üìÑ sorts.h                    # API completa do sistema
‚îÇ
‚îú‚îÄ‚îÄ üìÅ src/                           # C√≥digo fonte modularizado
‚îÇ   ‚îú‚îÄ‚îÄ üìÑ algoritmos.c               # Implementa√ß√µes dos algoritmos
‚îÇ   ‚îú‚îÄ‚îÄ üìÑ analise.c                  # Sistema de medi√ß√£o e an√°lise
‚îÇ   ‚îú‚îÄ‚îÄ üìÑ io.c                       # Entrada/sa√≠da e fun√ß√µes de compara√ß√£o
‚îÇ   ‚îî‚îÄ‚îÄ üìÑ utils.c                    # Utilit√°rios e interface
‚îÇ
‚îú‚îÄ‚îÄ üìÅ output/                        # Resultados organizados automaticamente
‚îÇ   ‚îú‚îÄ‚îÄ üìÅ numeros/                   # Arrays ordenados (n√∫meros)
‚îÇ   ‚îú‚îÄ‚îÄ üìÅ alunos/                    # Arrays ordenados (estruturas)
‚îÇ   ‚îú‚îÄ‚îÄ üìÅ relatorios/                # An√°lises de performance
‚îÇ   ‚îî‚îÄ‚îÄ üìÑ analise_estabilidade.txt   # Relat√≥rio de estabilidade
‚îÇ
‚îú‚îÄ‚îÄ üìÑ main.c                         # Programa principal
‚îú‚îÄ‚îÄ üìÑ CMakeLists.txt                 # Configura√ß√£o do CMake
‚îú‚îÄ‚îÄ üìÑ README.md                      # Este arquivo
‚îî‚îÄ‚îÄ üìÑ LICENSE                        # Licen√ßa MIT
```

## üõ†Ô∏è Compila√ß√£o e Execu√ß√£o

### **Pr√©-requisitos**

- **Compilador C**: GCC, Clang, MSVC ou compat√≠vel
- **CMake**: 3.10 ou superior (opcional)
- **Sistema**: Windows, Linux, macOS

### **M√©todo 1: CMake (Recomendado)**

```bash
# 1. Criar diret√≥rio de build
mkdir build && cd build

# 2. Configurar projeto
cmake ..

# 3. Compilar
cmake --build .

# 4. Executar
./trabalho_po_1        # Linux/macOS
trabalho_po_1.exe      # Windows
```

### **M√©todo 2: Compila√ß√£o Direta**

```bash
# GCC/Clang
gcc -o trabalho_po_1 main.c src/*.c -Iinclude -std=c99

# MSVC (Windows)
cl main.c src/*.c /Iinclude /Fe:trabalho_po_1.exe
```

### **M√©todo 3: IDEs Compat√≠veis**

- **CLion**: Abrir pasta do projeto
- **Visual Studio**: Usar "Abrir Pasta"
- **Code::Blocks**: Criar projeto e adicionar arquivos
- **Dev-C++**: Compila√ß√£o direta

## üìñ Manual de Uso

### **1. Execu√ß√£o Principal**

```
================================================================
              TRABALHO DE ALGORITMOS DE ORDENA√á√ÉO              
                    Programa√ß√£o Avan√ßada - 2025                
                Sistema Dual: Otimizada + Did√°tica             
================================================================

                        MENU PRINCIPAL                         
================================================================
  1. Gerar relat√≥rio completo de todos os testes               
     (Inclui an√°lise de ambas as vers√µes dos algoritmos)       
  0. Sair do programa                                           
================================================================
```

### **2. Processo Automatizado**

O programa executa automaticamente:

#### **üîÑ FASE 1: Vers√£o N√£o Otimizada**
- Testa todos os 6 conjuntos de n√∫meros
- Processa dados de alunos
- Gera m√©tricas detalhadas

#### **üîÑ FASE 2: Vers√£o Otimizada**
- Repete todos os testes com vers√µes otimizadas
- Compara performance
- Analisa diferen√ßas de implementa√ß√£o

#### **üîÑ FASE 3: An√°lise de Estabilidade**
- Testes espec√≠ficos com elementos duplicados
- Verifica√ß√£o de ordem relativa
- Relat√≥rio detalhado de estabilidade

#### **üîÑ FASE 4: Relat√≥rio Final**
- Consolida√ß√£o de todos os resultados
- Compara√ß√£o entre vers√µes
- √çndices de arquivos gerados

### **3. Tempo de Execu√ß√£o**

‚è±Ô∏è **Tempo estimado**: 2-5 minutos (dependendo do hardware)
- Conjuntos pequenos: ~10 segundos
- Conjuntos m√©dios: ~30 segundos  
- Conjuntos grandes: ~2 minutos
- An√°lises extras: ~30 segundos

## üìä An√°lise de Dados

### **üìà Conjuntos de Teste Dispon√≠veis**

#### **N√∫meros Inteiros (6 conjuntos):**

| Arquivo | Elementos | Prop√≥sito | Caracter√≠sticas |
|---------|-----------|-----------|-----------------|
| `numeros_pequeno.txt` | ~100 | Algoritmos O(n¬≤) | Execu√ß√£o r√°pida, boa para testes |
| `numeros_medio.txt` | ~1.000 | Diferencia√ß√£o | Mostra vantagens O(n log n) |
| `numeros_grande.txt` | ~10.000 | Performance | Destaca algoritmos eficientes |
| `numeros_ordenados.txt` | Variado | Melhor caso | Testa otimiza√ß√µes especiais |
| `numeros_reversos.txt` | Variado | Pior caso | For√ßa comportamento quadr√°tico |
| `numeros_duplicados.txt` | Variado | Estabilidade | Elementos repetidos |

#### **Dados Estruturados (1 conjunto):**

- **`alunos.txt`**: Estruturas com nome, data de nascimento, bairro e cidade
- **Prop√≥sito**: An√°lise de estabilidade e ordena√ß√£o por m√∫ltiplos crit√©rios
- **Formato**: CSV (nome,data,bairro,cidade)

### **üéØ Estrat√©gia de An√°lise**

O sistema realiza **an√°lise comparativa em 3 dimens√µes**:

1. **‚è±Ô∏è Temporal**: Tempo de execu√ß√£o com precis√£o de nanossegundos
2. **üî¢ Operacional**: Contagem de compara√ß√µes e trocas
3. **üé≤ Comportamental**: An√°lise de estabilidade e casos extremos

## üìÅ Arquivos de Sa√≠da

O sistema organiza automaticamente todos os resultados na pasta `output/`:

### **üìÅ output/numeros/**

Arrays de n√∫meros ordenados por cada algoritmo:

```
Bubble_Sort_otimizada_numeros_pequeno.txt
Bubble_Sort_nao_otimizada_numeros_pequeno.txt
Insertion_Sort_otimizada_numeros_grande.txt
Quick_Sort_otimizada_numeros_reversos.txt
[... todos os algoritmos √ó todos os conjuntos √ó 2 vers√µes]
```

### **üìÅ output/alunos/**

Dados de alunos ordenados por bairro e nome:

```
Bubble_Sort_otimizada_alunos.txt
Insertion_Sort_nao_otimizada_alunos.txt
[... todos os algoritmos √ó 2 vers√µes]
```

### **üìÅ output/relatorios/**

An√°lises detalhadas de performance:

```
relatorio_numeros_otimizada_numeros_pequeno.txt
relatorio_numeros_nao_otimizada_numeros_grande.txt
relatorio_alunos_otimizada_alunos.txt
relatorio_comparativo_final.txt
[... relat√≥rios por conjunto e vers√£o]
```

### **üìÑ output/analise_estabilidade.txt**

Relat√≥rio espec√≠fico sobre estabilidade dos algoritmos.

## üîß Documenta√ß√£o T√©cnica

### **‚öôÔ∏è Arquitetura do Sistema**

#### **Modulariza√ß√£o**
- **`main.c`**: Interface principal e controle de fluxo
- **`algoritmos.c`**: Implementa√ß√µes dual (otimizada/did√°tica)  
- **`analise.c`**: Sistema de medi√ß√£o de alta precis√£o
- **`io.c`**: Entrada/sa√≠da robusta e fun√ß√µes de compara√ß√£o
- **`utils.c`**: Utilit√°rios e gerenciamento de arquivos

#### **Caracter√≠sticas T√©cnicas**

##### **üéØ Algoritmos Gen√©ricos**
```c
// Assinatura padr√£o - funciona com qualquer tipo
void insertion_sort(void *arr, int n, size_t elem_size, CompareFn cmp);

// Fun√ß√£o de compara√ß√£o personalizada
typedef int (*CompareFn)(const void *a, const void *b);
```

##### **‚è±Ô∏è Sistema de Medi√ß√£o Avan√ßado**
```c
// Medi√ß√£o multiplataforma de alta precis√£o
double obter_timestamp_precisao();

// Medi√ß√£o adaptativa com m√∫ltiplas execu√ß√µes
double medir_tempo_multiplo(/* par√¢metros */);
```

##### **üîÑ Sistema Dual**
```c
// Configura√ß√£o global de vers√£o
extern int usar_versao_otimizada;
void configurar_otimizacao(int otimizada);

// Interfaces unificadas que alternam automaticamente
void insertion_sort(/*...*/);  // Chama vers√£o ativa
void insertion_sort_optimized(/*...*/);  // Vers√£o espec√≠fica
void insertion_sort_naive(/*...*/);      // Vers√£o espec√≠fica
```

### **üìä Estruturas de Dados**

#### **Informa√ß√µes de Algoritmo**
```c
typedef struct {
    char nome[30];
    char complexidade_melhor[15];
    char complexidade_media[15]; 
    char complexidade_pior[15];
    int eh_estavel;
    // Ponteiros de fun√ß√£o...
} AlgoritmoInfo;
```

#### **Resultados de Performance**
```c
typedef struct {
    char algoritmo[30];
    double tempo_execucao;      // Precis√£o de nanossegundos
    int tamanho_dados;
    char tipo_dados[20];
    long long comparacoes;      // Contagem precisa
    long long trocas;          // Contagem precisa
} ResultadoTempo;
```

## üìà M√©tricas Analisadas

### **1. ‚è±Ô∏è Tempo de Execu√ß√£o**

- **Precis√£o**: At√© nanossegundos (dependente do hardware)
- **M√©todo**: Medi√ß√£o antes/depois com timestamps de alta resolu√ß√£o
- **Adapta√ß√£o**: M√∫ltiplas execu√ß√µes para algoritmos muito r√°pidos
- **Garantia**: Nunca retorna zero (m√≠nimo 1 microssegundo)

### **2. üî¢ N√∫mero de Compara√ß√µes**

- **Contagem**: Intercepta√ß√£o transparente via wrapper
- **Precis√£o**: Todas as compara√ß√µes entre elementos
- **Uso**: An√°lise da complexidade real vs te√≥rica

### **3. üîÑ N√∫mero de Trocas/Movimenta√ß√µes**

- **Defini√ß√£o**: Qualquer movimenta√ß√£o de elementos
- **Inclui**: Trocas diretas, deslocamentos, inser√ß√µes
- **An√°lise**: Overhead de movimenta√ß√£o de dados

### **4. üéØ An√°lise de Estabilidade**

- **Teste**: Elementos com chaves iguais
- **Verifica√ß√£o**: Preserva√ß√£o da ordem relativa original
- **Casos**: Dados reais com alunos do mesmo bairro

### **5. üìä Rankings Autom√°ticos**

O sistema gera automaticamente rankings por:
- **‚ö° Tempo de execu√ß√£o** (mais r√°pido primeiro)
- **üî¢ N√∫mero de compara√ß√µes** (menos compara√ß√µes primeiro)
- **üîÑ N√∫mero de trocas** (menos movimenta√ß√µes primeiro)

### **6. üìã Relat√≥rios Comparativos**

- **Por conjunto**: Performance em cada tipo de dados
- **Por algoritmo**: Comportamento em diferentes cen√°rios  
- **Por vers√£o**: Otimizada vs N√£o Otimizada
- **Consolidado**: Vis√£o geral de todos os testes

## ü§ù Contribui√ß√£o

### **Como Contribuir**

1. **Fork** do reposit√≥rio
2. **Clone** sua fork localmente
3. **Crie** uma branch para sua feature (`git checkout -b feature/nova-funcionalidade`)
4. **Commit** suas mudan√ßas (`git commit -am 'Adiciona nova funcionalidade'`)
5. **Push** para a branch (`git push origin feature/nova-funcionalidade`)
6. **Abra** um Pull Request

### **√Åreas para Contribui√ß√£o**

- üî¨ **Novos algoritmos** (Merge Sort, Radix Sort, etc.)
- üìä **Novas m√©tricas** (uso de mem√≥ria, cache misses)
- üñ•Ô∏è **Interface gr√°fica** (visualiza√ß√£o em tempo real)
- üìà **An√°lises estat√≠sticas** (desvio padr√£o, intervalos de confian√ßa)
- üîß **Otimiza√ß√µes** (paraleliza√ß√£o, SIMD)

### **Padr√µes de C√≥digo**

- **Documenta√ß√£o**: Coment√°rios em portugu√™s, estilo Doxygen
- **Nomenclatura**: snake_case para fun√ß√µes e vari√°veis
- **Modulariza√ß√£o**: Separa√ß√£o clara de responsabilidades
- **Compatibilidade**: C√≥digo multiplataforma (Windows/Linux/macOS)

## üìÑ Licen√ßa

Este projeto est√° licenciado sob a **Licen√ßa MIT** - veja o arquivo [LICENSE](LICENSE) para detalhes.

```
MIT License

Copyright (c) 2025 Sistema de An√°lise de Algoritmos

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.
```

---

## üìû Contato e Suporte

**üìß Para d√∫vidas acad√™micas**: Consulte a documenta√ß√£o nos coment√°rios do c√≥digo
**üêõ Para reportar bugs**: Use as Issues do GitHub
**üí° Para sugest√µes**: Pull Requests s√£o bem-vindos

---

<div align="center">

**üèÜ Desenvolvido com foco em qualidade, precis√£o e usabilidade**

[![Made with ‚ù§Ô∏è](https://img.shields.io/badge/Made%20with-‚ù§Ô∏è-red.svg)]()
[![C Programming](https://img.shields.io/badge/C-Programming-blue.svg)]()
[![Academic Project](https://img.shields.io/badge/Academic-Project-green.svg)]()

**‚≠ê Se este projeto foi √∫til para voc√™, considere dar uma estrela!**

</div>
